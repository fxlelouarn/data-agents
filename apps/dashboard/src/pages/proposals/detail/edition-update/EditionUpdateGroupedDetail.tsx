import React from 'react'
import GroupedProposalDetailBase from '../base/GroupedProposalDetailBase'
import CategorizedEditionChangesTable from '@/components/proposals/CategorizedEditionChangesTable'
import DateSourcesSection from '@/components/proposals/DateSourcesSection'
import AgentInfoSection from '@/components/proposals/AgentInfoSection'
import EditionContextInfo from '@/components/proposals/EditionContextInfo'
import OrganizerSection from '@/components/proposals/edition-update/OrganizerSection'
import RacesChangesTable from '@/components/proposals/edition-update/RacesChangesTable'

interface EditionUpdateGroupedDetailProps {
  groupKey: string
}

// Champs vraiment auto-générés (slug, fullAddress, etc.) - filtrés côté backend
// Les champs calendarStatus, timeZone, endDate ne sont PLUS filtrés car ce sont de vraies propositions
const autoGeneratedFields = ['slug', 'fullAddress', 'currentEditionEventId', 'toUpdate', 'algoliaObjectToUpdate', 'algoliaObjectToDelete']

const EditionUpdateGroupedDetail: React.FC<EditionUpdateGroupedDetailProps> = ({ groupKey }) => {
  return (
    <GroupedProposalDetailBase
      groupKey={groupKey}
      renderMainContent={(context) => {
        const {
          consolidatedChanges,
          consolidatedRaceChanges,
          selectedChanges,
          userModifiedRaceChanges,
          handleFieldSelect,
          handleApproveField,
          handleFieldModify,
          handleEditionStartDateChange,
          handleApproveAll,
          handleRejectAll,
          handleApproveAllRaces,
          handleRejectAllRaces,
          handleRaceFieldModify,
          handleDeleteRace,
          handleReviveEvent,
          handleKillEvent,
          userModifiedChanges,
          formatValue,
          formatAgentsList,
          editionTimezone,
          allPending,
          isPending,
          isEventDead,
          setKillDialogOpen,
          isEditionCanceled,
          groupProposals,
          // Validation par bloc
          validateBlock,
          unvalidateBlock,
          isBlockValidated,
          isBlockPending,
          blockProposals
        } = context
        
        // Séparer les champs standards des champs spéciaux
        const standardChanges = consolidatedChanges.filter(c => 
          !['organizer', 'racesToAdd'].includes(c.field)
        )
        const organizerChange = consolidatedChanges.find(c => c.field === 'organizer')
        const racesToAddChange = consolidatedChanges.find(c => c.field === 'racesToAdd')
        
        
        // Ne garder que les champs qui ne sont PAS auto-générés
        const realStandardChanges = standardChanges.filter(c => 
          !autoGeneratedFields.includes(c.field)
        )
        
        // Afficher le tableau Edition seulement s'il y a de vrais changements
        const hasRealEditionChanges = realStandardChanges.length > 0
        
        // Calculer si on a des changements de courses
        const hasRaceChanges = consolidatedRaceChanges.length > 0
        
        return (
          <>
            {/* Table standard des champs d'édition - afficher seulement s'il y a de vrais changements */}
            {hasRealEditionChanges && (
              <CategorizedEditionChangesTable
                title="Édition"
                changes={realStandardChanges}
                isNewEvent={false}
                selectedChanges={selectedChanges}
                onFieldSelect={handleFieldSelect}
                onFieldApprove={handleApproveField}
                onFieldModify={handleFieldModify}
                onEditionStartDateChange={handleEditionStartDateChange}
                userModifiedChanges={userModifiedChanges}
                formatValue={formatValue}
                formatAgentsList={formatAgentsList}
                timezone={editionTimezone}
                disabled={isBlockValidated('edition') || isEventDead}
                isEditionCanceled={isEditionCanceled || isEventDead}
                isBlockValidated={isBlockValidated('edition')}
                onValidateBlock={() => validateBlock('edition', blockProposals['edition'] || [])}
                onUnvalidateBlock={() => unvalidateBlock('edition')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead}
              />
            )}
            
            {/* Section organisateur */}
            {organizerChange && (
              <OrganizerSection
                change={organizerChange}
                onApprove={() => handleApproveField('organizer')}
                onFieldModify={handleFieldModify}
                userModifiedChanges={userModifiedChanges}
                disabled={isBlockValidated('organizer') || isEventDead}
                isBlockValidated={isBlockValidated('organizer')}
                onValidateBlock={() => validateBlock('organizer', blockProposals['organizer'] || [])}
                onUnvalidateBlock={() => unvalidateBlock('organizer')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead}
              />
            )}
            
            {/* Section courses à ajouter */}
            {hasRaceChanges && (
              <RacesChangesTable
                consolidatedRaces={consolidatedRaceChanges}
                userModifiedRaceChanges={userModifiedRaceChanges}
                onRaceFieldModify={handleRaceFieldModify}
                onDeleteRace={handleDeleteRace}
                disabled={isBlockValidated('races') || isEventDead}
                isBlockValidated={isBlockValidated('races')}
                onValidateBlock={() => validateBlock('races', blockProposals['races'] || [])}
                onUnvalidateBlock={() => unvalidateBlock('races')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead}
              />
            )}
            
            {/* Sources des dates extraites */}
            <DateSourcesSection 
              justifications={groupProposals.flatMap(p => p.justification || [])} 
            />
          </>
        )
      }}
      renderSidebar={(context) => {
        const { 
          groupProposals, 
          getEditionYear, 
          selectedChanges, 
          userModifiedChanges,
          handleFieldModify,
          allPending
        } = context
        
        const firstProposal = groupProposals[0]
        
        return (
          <>
            {/* Informations contextuelles de l'édition */}
            {firstProposal && (
              <EditionContextInfo
                currentCalendarStatus={
                  userModifiedChanges['calendarStatus'] || 
                  selectedChanges['calendarStatus'] || 
                  (typeof firstProposal.changes.calendarStatus === 'string' 
                    ? firstProposal.changes.calendarStatus 
                    : (firstProposal.changes.calendarStatus as any)?.current || (firstProposal.changes.calendarStatus as any)?.proposed)
                }
                currentEditionYear={getEditionYear(firstProposal) ? parseInt(getEditionYear(firstProposal)!) : undefined}
                previousEditionYear={(firstProposal as any).previousEditionYear}
                previousCalendarStatus={(firstProposal as any).previousEditionCalendarStatus}
                previousEditionStartDate={(firstProposal as any).previousEditionStartDate}
                eventName={(firstProposal as any).eventName}
                eventSlug={(firstProposal as any).eventSlug}
              />
            )}
            
            <AgentInfoSection 
              proposals={groupProposals.map(p => ({ 
                ...p, 
                confidence: p.confidence || 0, 
                status: p.status 
              }))} 
            />
          </>
        )
      }}
    />
  )
}

export default EditionUpdateGroupedDetail
