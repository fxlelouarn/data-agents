import React, { useMemo } from 'react'
import { Box, LinearProgress } from '@mui/material'
import GroupedProposalDetailBase from '../base/GroupedProposalDetailBase'
import CategorizedEditionChangesTable from '@/components/proposals/CategorizedEditionChangesTable'
import CategorizedEventChangesTable from '@/components/proposals/CategorizedEventChangesTable'
import DateSourcesSection from '@/components/proposals/DateSourcesSection'
import AgentInfoSection from '@/components/proposals/AgentInfoSection'
import EditionContextInfo from '@/components/proposals/EditionContextInfo'
import OrganizerSection from '@/components/proposals/edition-update/OrganizerSection'
import RacesChangesTable from '@/components/proposals/edition-update/RacesChangesTable'
import { AlternativeMatchesCard } from '@/components/proposals/edition-update/AlternativeMatchesCard'
import {
  TwoPaneLayout,
  SourceProposalPane,
  CollapsibleContextCards
} from '@/components/proposals/grouped'
import { useProposalGroup } from '@/hooks/useApi'

interface EditionUpdateGroupedDetailProps {
  groupKey: string
}

// Champs vraiment auto-générés (slug, fullAddress, etc.) - filtrés côté backend
const autoGeneratedFields = ['slug', 'fullAddress', 'currentEditionEventId', 'toUpdate', 'algoliaObjectToUpdate', 'algoliaObjectToDelete']

const EditionUpdateGroupedDetail: React.FC<EditionUpdateGroupedDetailProps> = ({ groupKey }) => {
  // Récupérer le groupe pour avoir accès aux propositions
  const { data: groupData, isLoading: isGroupLoading } = useProposalGroup(groupKey)

  if (isGroupLoading) {
    return <LinearProgress />
  }

  return (
    <GroupedProposalDetailBase
      groupKey={groupKey}
      renderMainContent={(context) => {
        // ✅ Two-Panes: Utiliser les fonctions du contexte (provenant de GroupedProposalDetailBase)
        const {
          sourceProposals,
          activeSourceIndex,
          setActiveSourceIndex,
          copyFieldFromSource,
          copyRaceFromSource,
          copyAllFromSource,
          getFieldDifferences,
          getRaceDifferences
        } = context

        // Vérifier qu'on a plusieurs sources pour le mode two-panes
        const hasMultipleSources = sourceProposals.length > 1

        // Vérifier si tous les blocs sont validés
        const isAllValidated = 
          context.isBlockValidated('event') &&
          context.isBlockValidated('edition') &&
          context.isBlockValidated('races')

        // Si une seule source, utiliser le layout simple
        if (!hasMultipleSources) {
          return <MainContent context={context} />
        }

        // Mode Two-Panes : plusieurs sources disponibles
        const fieldDifferences = getFieldDifferences()
        const raceDifferences = getRaceDifferences()

        return (
          <>
            <TwoPaneLayout
              leftTitle="Proposition de travail"
              rightTitle="Sources"
              leftPane={
                <MainContent context={context} />
              }
              rightPane={
                <SourceProposalPane
                  sourceProposals={sourceProposals}
                  activeSourceIndex={activeSourceIndex}
                  onChangeSource={setActiveSourceIndex}
                  fieldDifferences={fieldDifferences}
                  raceDifferences={raceDifferences}
                  onCopyField={copyFieldFromSource}
                  onCopyRace={copyRaceFromSource}
                  onCopyAll={copyAllFromSource}
                  isValidated={isAllValidated}
                />
              }
            />

            {/* Cards contextuelles en dessous du TwoPanes */}
            <CollapsibleContextCards title="Informations contextuelles">
              {/* Passer les cards individuellement pour la disposition horizontale */}
              {(() => {
                const firstProposal = context.groupProposals[0]
                const rejectedMatches = firstProposal?.justification
                  ?.find((j: any) => j.type === 'rejected_matches' || j.metadata?.rejectedMatches)
                  ?.metadata?.rejectedMatches || []
                return firstProposal && rejectedMatches.length > 0 ? (
                  <AlternativeMatchesCard
                    proposalId={firstProposal.id}
                    currentEventId={firstProposal.eventId}
                    currentEventName={firstProposal.eventName}
                    rejectedMatches={rejectedMatches}
                  />
                ) : null
              })()}
              {context.groupProposals[0] && (
                <EditionContextInfo
                  currentCalendarStatus={
                    context.userModifiedChanges['calendarStatus'] ||
                    context.selectedChanges['calendarStatus'] ||
                    (typeof context.groupProposals[0].changes.calendarStatus === 'string'
                      ? context.groupProposals[0].changes.calendarStatus
                      : (context.groupProposals[0].changes.calendarStatus as any)?.current || (context.groupProposals[0].changes.calendarStatus as any)?.proposed)
                  }
                  currentEditionYear={context.getEditionYear(context.groupProposals[0]) ? parseInt(context.getEditionYear(context.groupProposals[0])!) : undefined}
                  previousEditionYear={(context.groupProposals[0] as any).previousEditionYear}
                  previousCalendarStatus={(context.groupProposals[0] as any).previousEditionCalendarStatus}
                  previousEditionStartDate={(context.groupProposals[0] as any).previousEditionStartDate}
                  eventName={(context.groupProposals[0] as any).eventName}
                  eventSlug={(context.groupProposals[0] as any).eventSlug}
                  isFeatured={context.groupProposals[0].isFeatured}
                />
              )}
              <AgentInfoSection
                proposals={context.allGroupProposals.map((p: any) => ({
                  ...p,
                  confidence: p.confidence || 0,
                  status: p.status
                }))}
                onArchive={context.handleArchiveSingleProposal}
                isArchiving={context.isArchiving}
              />
            </CollapsibleContextCards>
          </>
        )
      }}
      renderSidebar={(context) => {
        // En mode Two-Panes, pas de sidebar (cards affichées en dessous)
        const hasMultipleSources = context.sourceProposals.length > 1
        if (hasMultipleSources) {
          return null
        }
        return <SidebarContent context={context} />
      }}
    />
  )
}

// ═══════════════════════════════════════════════════════════════════════════════
// Composants internes extraits pour réutilisation
// ═══════════════════════════════════════════════════════════════════════════════

interface MainContentProps {
  context: any // GroupedProposalContext
}

/**
 * Contenu principal avec les tables d'édition
 */
const MainContent: React.FC<MainContentProps> = ({ context }) => {
  const {
    consolidatedChanges,
    consolidatedRaceChanges,
    selectedChanges,
    userModifiedRaceChanges,
    handleFieldSelect,
    handleApproveField,
    handleFieldModify,
    handleEditionStartDateChange,
    handleRaceFieldModify,
    handleDeleteRace,
    handleAddRace,
    userModifiedChanges,
    formatValue,
    formatAgentsList,
    editionTimezone,
    isPending,
    isEventDead,
    isEditionCanceled,
    groupProposals,
    isAllApproved,
    validateBlock,
    validateBlockWithDependencies,
    unvalidateBlock,
    isBlockValidated,
    isBlockPending,
    blockProposals
  } = context

  // Extraire la date d'édition pour pré-remplir AddRaceDialog
  const editionStartDate = useMemo(() => {
    if (userModifiedChanges?.startDate) {
      return userModifiedChanges.startDate
    }

    const startDateField = consolidatedChanges?.find((c: any) => c.field === 'startDate')
    if (startDateField) {
      return startDateField.options[0]?.proposedValue || startDateField.currentValue
    }

    const firstProposal = groupProposals[0]
    if (firstProposal?.changes?.startDate?.new) {
      return firstProposal.changes.startDate.new
    }

    if (userModifiedRaceChanges && Object.keys(userModifiedRaceChanges).length > 0) {
      const firstRaceWithDate = Object.values(userModifiedRaceChanges).find(
        (race: any) => race.startDate && !race._deleted
      )
      if (firstRaceWithDate && (firstRaceWithDate as any).startDate) {
        return (firstRaceWithDate as any).startDate
      }
    }

    if (consolidatedRaceChanges && consolidatedRaceChanges.length > 0) {
      const firstRaceWithDate = consolidatedRaceChanges.find(
        (race: any) => race.fields?.startDate || race.originalFields?.startDate
      )
      if (firstRaceWithDate) {
        return firstRaceWithDate.fields?.startDate || firstRaceWithDate.originalFields?.startDate
      }
    }

    return undefined
  }, [userModifiedChanges, consolidatedChanges, groupProposals, userModifiedRaceChanges, consolidatedRaceChanges])

  const editionTimeZone = useMemo(() => {
    return userModifiedChanges?.timeZone
      || consolidatedChanges?.find((c: any) => c.field === 'timeZone')?.options[0]?.proposedValue
      || groupProposals[0]?.changes?.timeZone?.new
      || 'Europe/Paris'
  }, [userModifiedChanges, consolidatedChanges, groupProposals])

  // Séparer les champs événement, édition et champs spéciaux
  const eventFields = ['name', 'city', 'country', 'countrySubdivisionNameLevel1',
    'countrySubdivisionNameLevel2', 'fullAddress', 'latitude', 'longitude',
    'websiteUrl', 'facebookUrl', 'instagramUrl', 'twitterUrl']

  const eventChanges = consolidatedChanges.filter((c: any) => eventFields.includes(c.field))
  const standardChanges = consolidatedChanges.filter((c: any) =>
    !eventFields.includes(c.field) && !['organizer', 'racesToAdd'].includes(c.field)
  )
  const organizerChange = consolidatedChanges.find((c: any) => c.field === 'organizer')

  // Ne garder que les champs qui ne sont PAS auto-générés
  const realStandardChanges = standardChanges.filter((c: any) =>
    !autoGeneratedFields.includes(c.field)
  )

  // Afficher le tableau Événement seulement s'il y a des changements OU si le bloc est validé
  const hasEventChanges = eventChanges.length > 0
  const shouldShowEventBlock = hasEventChanges || isBlockValidated('event')

  // Afficher le tableau Edition seulement s'il y a de vrais changements OU si le bloc est validé
  const hasRealEditionChanges = realStandardChanges.length > 0
  const shouldShowEditionBlock = hasRealEditionChanges || isBlockValidated('edition')

  // Calculer si on a des changements de courses OU si le bloc est validé
  const hasRaceChanges = consolidatedRaceChanges.length > 0
  const shouldShowRacesBlock = hasRaceChanges || isBlockValidated('races')

  return (
    <>
      {/* Bloc Événement */}
      {shouldShowEventBlock && (
        <CategorizedEventChangesTable
          title="Événement"
          changes={eventChanges}
          isNewEvent={false}
          selectedChanges={selectedChanges}
          onFieldSelect={handleFieldSelect}
          onFieldApprove={handleApproveField}
          onFieldModify={handleFieldModify}
          userModifiedChanges={userModifiedChanges}
          formatValue={formatValue}
          formatAgentsList={formatAgentsList}
          disabled={isBlockValidated('event') || isEventDead || isAllApproved}
          isBlockValidated={isBlockValidated('event')}
          onValidateBlock={() => validateBlock('event')}
          onValidateBlockWithDependencies={validateBlockWithDependencies}
          onUnvalidateBlock={() => unvalidateBlock('event')}
          isBlockPending={isBlockPending}
          validationDisabled={isEventDead || isAllApproved}
        />
      )}

      {/* Table standard des champs d'édition */}
      {shouldShowEditionBlock && (
        <CategorizedEditionChangesTable
          title="Édition"
          changes={realStandardChanges}
          isNewEvent={false}
          selectedChanges={selectedChanges}
          onFieldSelect={handleFieldSelect}
          onFieldApprove={handleApproveField}
          onFieldModify={handleFieldModify}
          onEditionStartDateChange={handleEditionStartDateChange}
          userModifiedChanges={userModifiedChanges}
          formatValue={formatValue}
          formatAgentsList={formatAgentsList}
          timezone={editionTimezone}
          disabled={isBlockValidated('edition') || isEventDead || isAllApproved}
          isEditionCanceled={isEditionCanceled || isEventDead}
          isBlockValidated={isBlockValidated('edition')}
          onValidateBlock={() => validateBlock('edition')}
          onValidateBlockWithDependencies={validateBlockWithDependencies}
          onUnvalidateBlock={() => unvalidateBlock('edition')}
          isBlockPending={isBlockPending}
          validationDisabled={isEventDead || isAllApproved}
        />
      )}

      {/* Section organisateur */}
      {(organizerChange || isBlockValidated('organizer')) && (
        <OrganizerSection
          change={organizerChange}
          onApprove={() => handleApproveField('organizer')}
          onFieldModify={handleFieldModify}
          userModifiedChanges={userModifiedChanges}
          disabled={isBlockValidated('organizer') || isEventDead || isAllApproved}
          isBlockValidated={isBlockValidated('organizer')}
          onValidateBlock={() => validateBlock('organizer')}
          onValidateBlockWithDependencies={validateBlockWithDependencies}
          onUnvalidateBlock={() => unvalidateBlock('organizer')}
          isBlockPending={isBlockPending}
          validationDisabled={isEventDead || isAllApproved}
        />
      )}

      {/* Section courses */}
      {shouldShowRacesBlock && (
        <RacesChangesTable
          consolidatedRaces={consolidatedRaceChanges}
          userModifiedRaceChanges={userModifiedRaceChanges}
          onRaceFieldModify={handleRaceFieldModify}
          onDeleteRace={handleDeleteRace}
          onAddRace={handleAddRace}
          editionStartDate={editionStartDate}
          editionTimeZone={editionTimeZone}
          disabled={isBlockValidated('races') || isEventDead || isAllApproved}
          isBlockValidated={isBlockValidated('races')}
          onValidateBlock={() => validateBlock('races')}
          onValidateBlockWithDependencies={validateBlockWithDependencies}
          onUnvalidateBlock={() => unvalidateBlock('races')}
          isBlockPending={isBlockPending}
          validationDisabled={isEventDead || isAllApproved}
        />
      )}

      {/* Sources des dates extraites */}
      <DateSourcesSection
        justifications={groupProposals.flatMap((p: any) => p.justification || [])}
      />
    </>
  )
}

interface SidebarContentProps {
  context: any // GroupedProposalContext
}

/**
 * Contenu de la sidebar avec les informations contextuelles
 */
const SidebarContent: React.FC<SidebarContentProps> = ({ context }) => {
  const {
    groupProposals,
    allGroupProposals,
    getEditionYear,
    selectedChanges,
    userModifiedChanges,
    handleArchiveSingleProposal,
    isArchiving
  } = context

  const firstProposal = groupProposals[0]

  // Extraire les rejectedMatches de la justification (pour alternatives de matching)
  const rejectedMatches = useMemo(() => {
    if (!firstProposal?.justification) return []
    const justifications = firstProposal.justification as any[]
    const matchEntry = justifications?.find(
      (j: any) => j.type === 'rejected_matches' || j.metadata?.rejectedMatches
    )
    return matchEntry?.metadata?.rejectedMatches || []
  }, [firstProposal?.justification])

  return (
    <>
      {/* Alternatives de matching si disponibles */}
      {firstProposal && rejectedMatches.length > 0 && (
        <AlternativeMatchesCard
          proposalId={firstProposal.id}
          currentEventId={firstProposal.eventId}
          currentEventName={firstProposal.eventName}
          rejectedMatches={rejectedMatches}
        />
      )}

      {/* Informations contextuelles de l'édition */}
      {firstProposal && (
        <EditionContextInfo
          currentCalendarStatus={
            userModifiedChanges['calendarStatus'] ||
            selectedChanges['calendarStatus'] ||
            (typeof firstProposal.changes.calendarStatus === 'string'
              ? firstProposal.changes.calendarStatus
              : (firstProposal.changes.calendarStatus as any)?.current || (firstProposal.changes.calendarStatus as any)?.proposed)
          }
          currentEditionYear={getEditionYear(firstProposal) ? parseInt(getEditionYear(firstProposal)!) : undefined}
          previousEditionYear={(firstProposal as any).previousEditionYear}
          previousCalendarStatus={(firstProposal as any).previousEditionCalendarStatus}
          previousEditionStartDate={(firstProposal as any).previousEditionStartDate}
          eventName={(firstProposal as any).eventName}
          eventSlug={(firstProposal as any).eventSlug}
          isFeatured={firstProposal.isFeatured}
        />
      )}

      {/* AgentInfoSection gère la séparation PENDING vs historique en interne */}
      <AgentInfoSection
        proposals={allGroupProposals.map((p: any) => ({
          ...p,
          confidence: p.confidence || 0,
          status: p.status
        }))}
        onArchive={handleArchiveSingleProposal}
        isArchiving={isArchiving}
      />
    </>
  )
}

export default EditionUpdateGroupedDetail
