import React, { useMemo } from 'react'
import GroupedProposalDetailBase from '../base/GroupedProposalDetailBase'
import CategorizedEditionChangesTable from '@/components/proposals/CategorizedEditionChangesTable'
import CategorizedEventChangesTable from '@/components/proposals/CategorizedEventChangesTable'
import DateSourcesSection from '@/components/proposals/DateSourcesSection'
import AgentInfoSection from '@/components/proposals/AgentInfoSection'
import EditionContextInfo from '@/components/proposals/EditionContextInfo'
import OrganizerSection from '@/components/proposals/edition-update/OrganizerSection'
import RacesChangesTable from '@/components/proposals/edition-update/RacesChangesTable'
import { AlternativeMatchesCard } from '@/components/proposals/edition-update/AlternativeMatchesCard'

interface EditionUpdateGroupedDetailProps {
  groupKey: string
}

// Champs vraiment auto-générés (slug, fullAddress, etc.) - filtrés côté backend
// Les champs calendarStatus, timeZone, endDate ne sont PLUS filtrés car ce sont de vraies propositions
const autoGeneratedFields = ['slug', 'fullAddress', 'currentEditionEventId', 'toUpdate', 'algoliaObjectToUpdate', 'algoliaObjectToDelete']

const EditionUpdateGroupedDetail: React.FC<EditionUpdateGroupedDetailProps> = ({ groupKey }) => {
  return (
    <GroupedProposalDetailBase
      groupKey={groupKey}
      renderMainContent={(context) => {
        const {
          consolidatedChanges,
          consolidatedRaceChanges,
          selectedChanges,
          userModifiedRaceChanges,
          handleFieldSelect,
          handleApproveField,
          handleFieldModify,
          handleEditionStartDateChange,
          handleApproveAll,
          handleRejectAll,
          handleApproveAllRaces,
          handleRejectAllRaces,
          handleRaceFieldModify,
          handleDeleteRace,
          handleAddRace,
          handleReviveEvent,
          handleKillEvent,
          userModifiedChanges,
          formatValue,
          formatAgentsList,
          editionTimezone,
          allPending,
          isPending,
          isEventDead,
          setKillDialogOpen,
          isEditionCanceled,
          groupProposals,
          isAllApproved, // ✅ Mode lecture seule (toutes APPROVED)
          // Validation par bloc
          validateBlock,
          validateBlockWithDependencies,  // ✅ Nouveau
          unvalidateBlock,
          isBlockValidated,
          isBlockPending,
          blockProposals
        } = context

        // Extraire la date d'édition pour pré-remplir AddRaceDialog
        const editionStartDate = useMemo(() => {
          // Priorité:
          // 1) userModifiedChanges (modifications manuelles)
          // 2) consolidatedChanges (propositions agents)
          // 3) changes.startDate.new (structure agent)
          // 4) édition existante (currentValue dans consolidatedChanges)
          // 5) courses déjà ajoutées manuellement
          // 6) courses consolidées existantes

          if (userModifiedChanges?.startDate) {
            return userModifiedChanges.startDate
          }

          const startDateField = consolidatedChanges?.find(c => c.field === 'startDate')
          if (startDateField) {
            // Priorité à la valeur proposée, sinon valeur actuelle
            return startDateField.options[0]?.proposedValue || startDateField.currentValue
          }

          const firstProposal = groupProposals[0]
          if (firstProposal?.changes?.startDate?.new) {
            return firstProposal.changes.startDate.new
          }

          // Fallback: chercher dans les courses déjà ajoutées manuellement
          if (userModifiedRaceChanges && Object.keys(userModifiedRaceChanges).length > 0) {
            const firstRaceWithDate = Object.values(userModifiedRaceChanges).find(
              (race: any) => race.startDate && !race._deleted
            )
            if (firstRaceWithDate && (firstRaceWithDate as any).startDate) {
              return (firstRaceWithDate as any).startDate
            }
          }

          // Fallback: chercher dans les courses consolidées existantes
          if (consolidatedRaceChanges && consolidatedRaceChanges.length > 0) {
            const firstRaceWithDate = consolidatedRaceChanges.find(
              race => race.fields?.startDate || race.originalFields?.startDate
            )
            if (firstRaceWithDate) {
              return firstRaceWithDate.fields?.startDate || firstRaceWithDate.originalFields?.startDate
            }
          }

          return undefined
        }, [userModifiedChanges, consolidatedChanges, groupProposals, userModifiedRaceChanges, consolidatedRaceChanges])

        const editionTimeZone = useMemo(() => {
          return userModifiedChanges?.timeZone
            || consolidatedChanges?.find(c => c.field === 'timeZone')?.options[0]?.proposedValue
            || groupProposals[0]?.changes?.timeZone?.new
            || 'Europe/Paris'
        }, [userModifiedChanges, consolidatedChanges, groupProposals])

        // Séparer les champs événement, édition et champs spéciaux
        const eventFields = ['name', 'city', 'country', 'countrySubdivisionNameLevel1',
          'countrySubdivisionNameLevel2', 'fullAddress', 'latitude', 'longitude',
          'websiteUrl', 'facebookUrl', 'instagramUrl', 'twitterUrl']

        const eventChanges = consolidatedChanges.filter(c => eventFields.includes(c.field))
        const standardChanges = consolidatedChanges.filter(c =>
          !eventFields.includes(c.field) && !['organizer', 'racesToAdd'].includes(c.field)
        )
        const organizerChange = consolidatedChanges.find(c => c.field === 'organizer')
        const racesToAddChange = consolidatedChanges.find(c => c.field === 'racesToAdd')


        // Ne garder que les champs qui ne sont PAS auto-générés
        const realStandardChanges = standardChanges.filter(c =>
          !autoGeneratedFields.includes(c.field)
        )

        // Afficher le tableau Événement seulement s'il y a des changements OU si le bloc est validé
        const hasEventChanges = eventChanges.length > 0
        const shouldShowEventBlock = hasEventChanges || isBlockValidated('event')

        // Afficher le tableau Edition seulement s'il y a de vrais changements OU si le bloc est validé
        const hasRealEditionChanges = realStandardChanges.length > 0
        const shouldShowEditionBlock = hasRealEditionChanges || isBlockValidated('edition')

        // Calculer si on a des changements de courses OU si le bloc est validé
        const hasRaceChanges = consolidatedRaceChanges.length > 0
        const shouldShowRacesBlock = hasRaceChanges || isBlockValidated('races')

        return (
          <>
            {/* Bloc Événement - afficher s'il y a des changements OU si le bloc est validé */}
{shouldShowEventBlock && (
              <CategorizedEventChangesTable
                title="Événement"
                changes={eventChanges}
                isNewEvent={false}
                selectedChanges={selectedChanges}
                onFieldSelect={handleFieldSelect}
                onFieldApprove={handleApproveField}
                onFieldModify={handleFieldModify}
                userModifiedChanges={userModifiedChanges}
                formatValue={formatValue}
                formatAgentsList={formatAgentsList}
                disabled={isBlockValidated('event') || isEventDead || isAllApproved}
                isBlockValidated={isBlockValidated('event')}
                onValidateBlock={() => validateBlock('event', blockProposals['event'] || [])}
                onValidateBlockWithDependencies={validateBlockWithDependencies}  // ✅ Nouveau
                onUnvalidateBlock={() => unvalidateBlock('event')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead || isAllApproved}
              />
            )}

            {/* Table standard des champs d'édition - afficher s'il y a des changements OU si le bloc est validé */}
            {shouldShowEditionBlock && (
              <CategorizedEditionChangesTable
                title="Édition"
                changes={realStandardChanges}
                isNewEvent={false}
                selectedChanges={selectedChanges}
                onFieldSelect={handleFieldSelect}
                onFieldApprove={handleApproveField}
                onFieldModify={handleFieldModify}
                onEditionStartDateChange={handleEditionStartDateChange}
                userModifiedChanges={userModifiedChanges}
                formatValue={formatValue}
                formatAgentsList={formatAgentsList}
                timezone={editionTimezone}
                disabled={isBlockValidated('edition') || isEventDead || isAllApproved}
                isEditionCanceled={isEditionCanceled || isEventDead}
                isBlockValidated={isBlockValidated('edition')}
                onValidateBlock={() => validateBlock('edition', blockProposals['edition'] || [])}
                onValidateBlockWithDependencies={validateBlockWithDependencies}  // ✅ Nouveau
                onUnvalidateBlock={() => unvalidateBlock('edition')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead || isAllApproved}
              />
            )}

            {/* Section organisateur - afficher s'il y a un changement OU si le bloc est validé */}
            {(organizerChange || isBlockValidated('organizer')) && (
              <OrganizerSection
                change={organizerChange}
                onApprove={() => handleApproveField('organizer')}
                onFieldModify={handleFieldModify}
                userModifiedChanges={userModifiedChanges}
                disabled={isBlockValidated('organizer') || isEventDead || isAllApproved}
                isBlockValidated={isBlockValidated('organizer')}
                onValidateBlock={() => validateBlock('organizer', blockProposals['organizer'] || [])}
                onValidateBlockWithDependencies={validateBlockWithDependencies}  // ✅ Nouveau
                onUnvalidateBlock={() => unvalidateBlock('organizer')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead || isAllApproved}
              />
            )}

            {/* Section courses à ajouter - afficher s'il y a des changements OU si le bloc est validé */}
            {shouldShowRacesBlock && (
              <RacesChangesTable
                consolidatedRaces={consolidatedRaceChanges}
                userModifiedRaceChanges={userModifiedRaceChanges}
                onRaceFieldModify={handleRaceFieldModify}
                onDeleteRace={handleDeleteRace}
                onAddRace={handleAddRace}
                editionStartDate={editionStartDate}
                editionTimeZone={editionTimeZone}
                disabled={isBlockValidated('races') || isEventDead || isAllApproved}
                isBlockValidated={isBlockValidated('races')}
                onValidateBlock={() => validateBlock('races', blockProposals['races'] || [])}
                onValidateBlockWithDependencies={validateBlockWithDependencies}  // ✅ Nouveau
                onUnvalidateBlock={() => unvalidateBlock('races')}
                isBlockPending={isBlockPending}
                validationDisabled={isEventDead || isAllApproved}
              />
            )}

            {/* Sources des dates extraites */}
            <DateSourcesSection
              justifications={groupProposals.flatMap(p => p.justification || [])}
            />
          </>
        )
      }}
      renderSidebar={(context) => {
        const {
          groupProposals, // ✅ PENDING uniquement
          allGroupProposals, // ✅ Toutes les propositions (PENDING + historiques)
          getEditionYear,
          selectedChanges,
          userModifiedChanges,
          handleFieldModify,
          allPending,
          handleArchiveSingleProposal,
          isArchiving
        } = context

        const firstProposal = groupProposals[0]

        // Extraire les rejectedMatches de la justification (pour alternatives de matching)
        const rejectedMatches = useMemo(() => {
          if (!firstProposal?.justification) return []
          const justifications = firstProposal.justification as any[]
          const matchEntry = justifications?.find(
            (j: any) => j.type === 'rejected_matches' || j.metadata?.rejectedMatches
          )
          return matchEntry?.metadata?.rejectedMatches || []
        }, [firstProposal?.justification])

        return (
          <>
            {/* Alternatives de matching si disponibles */}
            {firstProposal && rejectedMatches.length > 0 && (
              <AlternativeMatchesCard
                proposalId={firstProposal.id}
                currentEventId={firstProposal.eventId}
                currentEventName={firstProposal.eventName}
                rejectedMatches={rejectedMatches}
              />
            )}

            {/* Informations contextuelles de l'édition */}
            {firstProposal && (
              <EditionContextInfo
                currentCalendarStatus={
                  userModifiedChanges['calendarStatus'] ||
                  selectedChanges['calendarStatus'] ||
                  (typeof firstProposal.changes.calendarStatus === 'string'
                    ? firstProposal.changes.calendarStatus
                    : (firstProposal.changes.calendarStatus as any)?.current || (firstProposal.changes.calendarStatus as any)?.proposed)
                }
                currentEditionYear={getEditionYear(firstProposal) ? parseInt(getEditionYear(firstProposal)!) : undefined}
                previousEditionYear={(firstProposal as any).previousEditionYear}
                previousCalendarStatus={(firstProposal as any).previousEditionCalendarStatus}
                previousEditionStartDate={(firstProposal as any).previousEditionStartDate}
                eventName={(firstProposal as any).eventName}
                eventSlug={(firstProposal as any).eventSlug}
                isFeatured={firstProposal.isFeatured}
              />
            )}

            {/* ✅ AgentInfoSection gère la séparation PENDING vs historique en interne */}
            <AgentInfoSection
              proposals={allGroupProposals.map(p => ({
                ...p,
                confidence: p.confidence || 0,
                status: p.status
              }))}
              onArchive={handleArchiveSingleProposal}
              isArchiving={isArchiving}
            />
          </>
        )
      }}
    />
  )
}

export default EditionUpdateGroupedDetail
