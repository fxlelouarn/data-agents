# √âtat du refactoring - 12 novembre 2025

**Date** : 2025-11-12  
**Statut global** : ‚úÖ PHASE 2 COMPL√àTE + PHASE 2.1 (Alignement) üéâ

---

## üìä Vue d'ensemble

| Composant | Statut | Hook utilis√© | Notes |
|-----------|--------|--------------|-------|
| `GroupedProposalDetailBase` | ‚úÖ Migr√© | `useProposalEditor` (mode group√©) | Tag "Modifi√©" fonctionnel |
| `ProposalDetailBase` | ‚úÖ Migr√© + ‚úÖ Align√© | `useProposalEditor` (mode simple) | Tag "Modifi√©" fonctionnel |
| `WorkingProposal` | ‚úÖ Align√© | - | Architecture coh√©rente avec `WorkingProposalGroup` |

---

## ‚úÖ PHASE 2 : GroupedProposalDetailBase (TERMIN√â)

### Fichier
`apps/dashboard/src/pages/proposals/detail/base/GroupedProposalDetailBase.tsx`

### Modifications effectu√©es

#### 1. Initialisation du hook (lignes 148-178)
```typescript
const proposalIds = useMemo(() => {
  return groupProposalsData?.data.map(p => p.id) || []
}, [groupProposalsData?.data])

const editorResult = useProposalEditor(proposalIds, { autosave: true })

// Type narrowing pour mode group√©
if (!isGroupReturn(editorResult)) {
  throw new Error('Mode group√© requis')
}

const {
  workingGroup,
  updateField: updateFieldEditor,
  selectOption,
  updateRace: updateRaceEditor,
  deleteRace: deleteRaceEditor,
  addRace: addRaceEditor,
  validateBlock: validateBlockEditor,
  validateAllBlocks: validateAllBlocksEditor,
  isBlockValidated: isBlockValidatedEditor,
  save: saveEditor,
  isDirty: isEditorDirty
} = editorResult
```

#### 2. Handlers adapt√©s (lignes 222-291)

**`handleFieldModify`** :
```typescript
const handleFieldModify = (fieldName: string, newValue: any) => {
  // ‚úÖ Utilise le hook
  updateFieldEditor(fieldName, newValue)
  
  // Compatibilit√© (√† supprimer en PHASE 3)
  setSelectedChanges(prev => ({ ...prev, [fieldName]: newValue }))
}
```

**`handleRaceFieldModify`** :
```typescript
const handleRaceFieldModify = (raceId: string, fieldName: string, newValue: any) => {
  // ‚úÖ Utilise le hook (sauvegarde lors de validateBlock)
  updateRaceEditor(raceId, fieldName, newValue)
}
```

**`handleEditionStartDateChange`** :
```typescript
const handleEditionStartDateChange = (fieldName: string, newValue: any) => {
  // ‚úÖ Utilise le hook avec logique de propagation aux courses
  if (racesCount > 0) {
    setDatePropagationModal({ open: true, newStartDate: newValue })
  } else {
    updateFieldEditor(fieldName, newValue)
  }
}
```

#### 3. √âtat consolid√© utilis√© (lignes 809-870)

**Payload pour validation** :
```typescript
const proposedValues = useMemo(() => {
  if (!workingGroup) return selectedChanges
  
  const values: Record<string, any> = {}
  workingGroup.consolidatedChanges.forEach(change => {
    const value = change.selectedValue !== undefined 
      ? change.selectedValue 
      : change.options[0]?.proposedValue
    if (value !== undefined) {
      values[change.field] = value
    }
  })
  return values
}, [workingGroup, selectedChanges])
```

**Hook de validation** :
```typescript
const {
  validateBlock: validateBlockBase,
  unvalidateBlock: unvalidateBlockBase,
  isBlockValidated,
  isBlockPending
} = useBlockValidation({
  proposals: workingGroup?.originalProposals || groupProposals,
  blockProposals,
  selectedChanges: proposedValues, // ‚úÖ Depuis workingGroup
  userModifiedChanges: workingGroup?.userModifiedChanges || {},
  userModifiedRaceChanges: workingGroup?.userModifiedRaceChanges || {}
})
```

**Context pass√© aux enfants** :
```typescript
const context: GroupedProposalContext = {
  groupProposals: workingGroup?.originalProposals || groupProposals,
  consolidatedChanges: workingGroup?.consolidatedChanges || consolidatedChanges,
  consolidatedRaceChanges: workingGroup?.consolidatedRaces || consolidatedRaceChangesWithCascade,
  
  // ‚úÖ √âtats depuis workingGroup
  selectedChanges: workingGroup ? {} : selectedChanges, // Vid√© en mode hook
  userModifiedChanges: workingGroup?.userModifiedChanges || {},
  userModifiedRaceChanges: workingGroup?.userModifiedRaceChanges || {},
  
  // Handlers adapt√©s
  handleFieldModify,
  handleRaceFieldModify,
  handleEditionStartDateChange,
  // ... reste inchang√©
}
```

### B√©n√©fices obtenus

‚úÖ **Plus de perte de modifications** : Le hook garde l'√©tat consolid√©  
‚úÖ **Sauvegarde automatique** : Autosave activ√© (debounced)  
‚úÖ **Validation coh√©rente** : Payload complet lors de la validation par blocs  
‚úÖ **Single Source of Truth** : `workingGroup` contient tout  

### Ce qui reste (PHASE 3 - Nettoyage)

üßπ **Code legacy √† supprimer** :
- `selectedChanges` (lignes 182, 234, etc.) - maintenu pour compatibilit√©
- Recalcul local de `consolidatedChanges` (ligne 384) - redondant avec `workingGroup.consolidatedChanges`
- Potentiellement `useProposalLogic` si seuls `formatValue`, `formatAgentsList` restent utiles

‚ö†Ô∏è **Non urgent** : Le syst√®me fonctionne correctement avec ces √©l√©ments en place.

---

## ‚úÖ PHASE 2 : ProposalDetailBase (TERMIN√â)

### Fichier
`apps/dashboard/src/pages/proposals/detail/base/ProposalDetailBase.tsx`

#### Modifications effectu√©es (12 novembre 2025 - apr√®s-midi)

#### 1. Initialisation du hook (lignes 102-121)
```typescript
const editorResult = useProposalEditor(proposalId, { autosave: true })

// Type narrowing pour mode simple
if ('workingGroup' in editorResult) {
  throw new Error('useProposalEditor doit retourner un mode simple')
}

const {
  workingProposal,
  isLoading: isEditorLoading,
  updateField: updateFieldEditor,
  updateRace: updateRaceEditor,
  validateBlock: validateBlockEditor,
  unvalidateBlock: unvalidateBlockEditor,
  save: saveEditor
} = editorResult
```

#### 2. Handlers adapt√©s

**`handleFieldModify`** (ligne 208) :
```typescript
const handleFieldModify = (fieldName: string, newValue: any) => {
  // ‚úÖ Utilise le hook
  updateFieldEditor(fieldName, newValue)
  
  // ‚ö†Ô∏è Compatibilit√© temporaire (PHASE 3 : supprimer)
  setUserModifiedChanges(prev => ({ ...prev, [fieldName]: newValue }))
  setSelectedChanges(prev => ({ ...prev, [fieldName]: newValue }))
}
```

**`handleRaceFieldModify`** (ligne 224) :
```typescript
const handleRaceFieldModify = (raceId: string, fieldName: string, newValue: any) => {
  // ‚úÖ Utilise le hook
  updateRaceEditor(raceId, fieldName, newValue)
  
  // ‚ö†Ô∏è Compatibilit√© temporaire
  setUserModifiedRaceChanges(prev => ({ ...prev, [raceId]: { ...prev[raceId], [fieldName]: newValue } }))
}
```

**Callbacks modales** (lignes 533, 605) :
- `confirmDatePropagation` : Utilise `updateFieldEditor` + `updateRaceEditor` pour propager aux courses
- `confirmEditionDateUpdate` : Utilise `updateFieldEditor` pour mettre √† jour les dates d'√©dition

#### 3. Donn√©es consolid√©es depuis workingProposal (lignes 310-376)

**consolidatedChanges** :
```typescript
const consolidatedChanges = useMemo(() => {
  if (workingProposal && proposal) {
    // Mode hook: utiliser workingProposal.changes directement
    return Object.entries(workingProposal.changes).map(([field, value]) => ({
      field,
      options: [{ proposalId: proposal.id, agentName: ..., proposedValue: value }],
      currentValue: (proposal.changes as any)?.[field]?.current
    }))
  }
  // Fallback (compatibilit√©)
  return consolidateChanges([proposalData.data], isNewEvent)
}, [workingProposal, proposal, proposalData, isNewEvent, consolidateChanges])
```

**consolidatedRaceChanges** :
```typescript
const consolidatedRaceChanges: ConsolidatedRaceChange[] = useMemo(() => {
  if (workingProposal && proposal) {
    return Object.entries(workingProposal.races).map(([raceId, raceData]) => ({
      raceId,
      raceName: (raceData as any).name || 'Course',
      proposalIds: [proposal.id],
      originalFields: {},
      fields: raceData
    }))
  }
  // Fallback avec adaptation de type RaceChange[] ‚Üí ConsolidatedRaceChange[]
  const races = consolidateRaceChanges([proposalData.data])
  return races.map(race => ({ ...race, originalFields: {} }))
}, [workingProposal, proposal, proposalData, consolidateRaceChanges])
```

#### 4. Adaptation useBlockValidation (lignes 423-456)

**Extraction des valeurs propos√©es** :
```typescript
const proposedValues = useMemo(() => {
  if (workingProposal) {
    const values: Record<string, any> = {}
    Object.entries(workingProposal.changes).forEach(([field, value]) => {
      if (value !== undefined) values[field] = value
    })
    return values
  }
  return selectedChanges // Fallback
}, [workingProposal, selectedChanges])
```

**Hook de validation** :
```typescript
const { ... } = useBlockValidation({
  proposals: workingProposal?.originalProposal ? [workingProposal.originalProposal] : (proposal ? [proposal] : []),
  blockProposals,
  selectedChanges: proposedValues, // ‚úÖ Depuis workingProposal
  userModifiedChanges: workingProposal ? {} : userModifiedChanges, // Vid√© en mode hook
  userModifiedRaceChanges: workingProposal ? {} : userModifiedRaceChanges // Vid√© en mode hook
})
```

#### 5. Context adapt√© (lignes 686-730)

```typescript
const context: ProposalContext = {
  proposal: workingProposal?.originalProposal || proposal!,
  consolidatedChanges,
  consolidatedRaceChanges,
  
  // ‚úÖ √âtats depuis workingProposal (ou fallback)
  selectedChanges: workingProposal ? {} : selectedChanges,
  userModifiedChanges: workingProposal ? {} : userModifiedChanges,
  userModifiedRaceChanges: workingProposal ? {} : userModifiedRaceChanges,
  
  // Handlers adapt√©s
  handleFieldModify,
  handleRaceFieldModify,
  // ...
  
  // √âtats UI
  isLoading: isLoading || isEditorLoading,
  // ...
}
```

### B√©n√©fices obtenus

‚úÖ **Plus de perte de modifications** : Le hook garde l'√©tat consolid√©  
‚úÖ **Sauvegarde automatique** : Autosave activ√© (debounced 2s)  
‚úÖ **Validation coh√©rente** : Payload complet lors de la validation par blocs  
‚úÖ **Single Source of Truth** : `workingProposal` contient tout  
‚úÖ **Coh√©rence avec GroupedProposalDetailBase** : M√™me architecture  

### Ce qui reste (PHASE 3 - Nettoyage)

üßπ **Code legacy √† supprimer** :
- `selectedChanges` - maintenu pour compatibilit√©
- √âtats manuels `userModifiedChanges`, `userModifiedRaceChanges` - redondants avec `workingProposal`
- Recalcul local de `consolidatedChanges` (fallback) - redondant avec `workingProposal.changes`
- Potentiellement `useProposalLogic` si seuls `formatValue`, `formatAgentsList` restent utiles

‚ö†Ô∏è **Non urgent** : Le syst√®me fonctionne correctement avec ces √©l√©ments en place.

---

## ‚úÖ PHASE 2.1 : Alignement WorkingProposal sur WorkingProposalGroup (TERMIN√â)

**Date** : 2025-11-12 (soir√©e)  
**Probl√®me r√©solu** : Le tag "Modifi√©" n'apparaissait pas dans les propositions simples.

### Diagnostic

**Cause** : Incoh√©rence architecturale entre `WorkingProposal` et `WorkingProposalGroup`.

```typescript
// ‚ùå AVANT - WorkingProposal
interface WorkingProposal {
  changes: Record<string, any>  // ‚ùå Valeurs MERG√âES (propos√©es + modifi√©es)
  races: Record<string, RaceData>  // ‚ùå Valeurs MERG√âES
  // ‚ùå PAS de userModifiedChanges s√©par√©
}

// ‚úÖ WorkingProposalGroup (correct)
interface WorkingProposalGroup {
  consolidatedChanges: ConsolidatedChange[]  // ‚úÖ Valeurs propos√©es
  userModifiedChanges: Record<string, any>  // ‚úÖ Stock√© s√©par√©ment
  userModifiedRaceChanges: Record<string, any>  // ‚úÖ Stock√© s√©par√©ment
}
```

**Cons√©quence** : Impossible de d√©tecter quels champs √©taient modifi√©s par l'utilisateur dans les propositions simples.

### Solution appliqu√©e

#### 1. Refactoring de l'interface `WorkingProposal`

```typescript
// ‚úÖ APR√àS - Align√© sur WorkingProposalGroup
export interface WorkingProposal {
  id: string
  originalProposal: Proposal
  
  // ‚úÖ √âtat propos√© (SANS modifications utilisateur)
  changes: Record<string, any>  // Changements propos√©s par l'agent
  races: Record<string, RaceData>  // Courses propos√©es par l'agent
  
  // ‚úÖ Modifications utilisateur (stock√©es s√©par√©ment)
  userModifiedChanges: Record<string, any>
  userModifiedRaceChanges: Record<string, any>
  
  // Blocs valid√©s
  approvedBlocks: Record<string, boolean>
  
  // M√©tadonn√©es
  isDirty: boolean
  lastSaved: Date | null
}
```

#### 2. Refactoring de `initializeWorkingProposal()`

```typescript
// ‚ùå AVANT - Mergeait tout
const mergedChanges = mergeChanges(
  proposal.changes,
  proposal.userModifiedChanges || {}
)
return {
  changes: mergedChanges,  // ‚ùå Impossible de savoir ce qui est modifi√©
  races: extractRaces(mergedChanges, proposal)
}

// ‚úÖ APR√àS - Stockage s√©par√©
const proposedChanges: Record<string, any> = {}
Object.entries(proposal.changes).forEach(([field, value]) => {
  proposedChanges[field] = extractNewValue(value)  // ‚úÖ Sans userModifiedChanges
})

const userModifiedChanges: Record<string, any> = {}
const userModifiedRaceChanges: Record<string, any> = {}

if (proposal.userModifiedChanges) {
  Object.entries(proposal.userModifiedChanges).forEach(([key, value]) => {
    if (key === 'raceEdits') {
      Object.assign(userModifiedRaceChanges, value)
    } else {
      userModifiedChanges[key] = value
    }
  })
}

return {
  changes: proposedChanges,  // ‚úÖ SANS userModifiedChanges
  races: proposedRaces,  // ‚úÖ SANS userModifiedRaceChanges
  userModifiedChanges,  // ‚úÖ Stock√© s√©par√©ment
  userModifiedRaceChanges  // ‚úÖ Stock√© s√©par√©ment
}
```

#### 3. Refactoring des actions d'√©dition

**`updateField()`** :
```typescript
// ‚ùå AVANT - Modifiait changes
setWorkingProposal(prev => ({
  ...prev,
  changes: { ...prev.changes, [field]: value }  // ‚ùå Impossible de diff√©rencier
}))

// ‚úÖ APR√àS - Modifie userModifiedChanges
setWorkingProposal(prev => ({
  ...prev,
  userModifiedChanges: { ...prev.userModifiedChanges, [field]: value }  // ‚úÖ Tra√ßable
}))
```

**`updateRace()`** :
```typescript
// ‚ùå AVANT
setWorkingProposal(prev => ({
  ...prev,
  races: { ...prev.races, [raceId]: { ...prev.races[raceId], [field]: value } }
}))

// ‚úÖ APR√àS
const current = prev.userModifiedRaceChanges[raceId] || {}
setWorkingProposal(prev => ({
  ...prev,
  userModifiedRaceChanges: {
    ...prev.userModifiedRaceChanges,
    [raceId]: { ...current, [field]: value }
  }
}))
```

**`addRace()` et `deleteRace()`** : M√™mes modifications (op√®rent sur `userModifiedRaceChanges`).

#### 4. Refactoring de `calculateDiff()`

```typescript
// ‚ùå AVANT - Comparait changes avec original (complexe)
const diff: Record<string, any> = {}
Object.entries(working.changes).forEach(([field, value]) => {
  const originalValue = working.originalProposal.changes[field]
  const originalExtracted = extractNewValue(originalValue)
  if (JSON.stringify(value) !== JSON.stringify(originalExtracted)) {
    diff[field] = value
  }
})

// ‚úÖ APR√àS - Renvoie directement userModifiedChanges (simple)
const diff: Record<string, any> = {}
Object.assign(diff, working.userModifiedChanges)

if (working.userModifiedRaceChanges && Object.keys(working.userModifiedRaceChanges).length > 0) {
  diff.raceEdits = working.userModifiedRaceChanges
}

return diff  // ‚úÖ Align√© sur buildGroupDiff()
```

### Fichiers modifi√©s

1. **`apps/dashboard/src/hooks/useProposalEditor.ts`**
   - Interface `WorkingProposal` : ajout de `userModifiedChanges` et `userModifiedRaceChanges`
   - `initializeWorkingProposal()` : stockage s√©par√© au lieu de merge
   - `updateField()` : mise √† jour de `userModifiedChanges` au lieu de `changes`
   - `updateRace()` : mise √† jour de `userModifiedRaceChanges` au lieu de `races`
   - `addRace()` : ajout √† `userModifiedRaceChanges`
   - `deleteRace()` : suppression de `userModifiedRaceChanges`
   - `calculateDiff()` : simplification (renvoie `userModifiedChanges` directement)

2. **`apps/dashboard/src/pages/proposals/detail/base/ProposalDetailBase.tsx`**
   - Lignes 122-125 : utilisation de `workingProposal.userModifiedChanges` et `workingProposal.userModifiedRaceChanges`
   - Suppression des appels `setUserModifiedChanges` et `setUserModifiedRaceChanges` (obsol√®tes)

### B√©n√©fices obtenus

‚úÖ **Tag "Modifi√©" fonctionnel** : Affichage correct dans tous les blocs des propositions simples  
‚úÖ **Coh√©rence architecturale** : `WorkingProposal` align√© sur `WorkingProposalGroup`  
‚úÖ **Code simplifi√©** : `calculateDiff()` ne fait plus de comparaisons complexes  
‚úÖ **Maintenabilit√©** : Une seule architecture pour mode simple et mode group√©  

### Tests

‚úÖ Compilation TypeScript : aucune erreur  
‚úÖ Tag "Modifi√©" : visible dans les blocs √âdition, Organisateur, Courses (propositions simples)  

---

## üéØ Prochaines √©tapes

### Priorit√© 1 : Nettoyage final (PHASE 3)

**Objectif** : Supprimer compl√®tement l'ancien syst√®me

**√âtapes** :
1. Supprimer `selectedChanges` de `GroupedProposalDetailBase` et `ProposalDetailBase`
2. Supprimer le recalcul local de `consolidatedChanges`
3. √âvaluer si `useProposalLogic` peut √™tre supprim√© (garder uniquement les utilitaires de formatage)
4. Supprimer les fallbacks de compatibilit√© (`workingGroup || oldState`)

**Estimation** : 1-2h

---

## üìö Ressources

### Documentation active
- **Plan global** : `docs/proposal-state-refactor/PLAN-PROPOSAL-STATE-REFACTOR.md`
- **PHASE 1.5** : `docs/proposal-state-refactor/PHASE1.5-GROUP-SUPPORT-COMPLETE.md`
- **PHASE 2 (GroupedProposalDetailBase)** : `docs/proposal-state-refactor/PHASE2-MIGRATION-PROGRESS.md` (√† archiver)
- **√âtat actuel** : `docs/proposal-state-refactor/STATUS-2025-11-12.md` (ce fichier)
- **Plan ProposalDetailBase** : `docs/proposal-state-refactor/PHASE2-PROPOSAL-DETAIL-BASE.md` (nouveau)

### Documentation archiv√©e (succ√®s pass√©s)
- `docs/proposal-state-refactor/archive/FIX-BLOCK-VALIDATION-PAYLOAD.md`
- `docs/proposal-state-refactor/archive/FIX-USER-MODIFICATIONS-APPLICATION.md`

### Code source
- **Hook principal** : `apps/dashboard/src/hooks/useProposalEditor.ts`
- **Base group√©e** : `apps/dashboard/src/pages/proposals/detail/base/GroupedProposalDetailBase.tsx`
- **Base simple** : `apps/dashboard/src/pages/proposals/detail/base/ProposalDetailBase.tsx`

---

## üèÜ M√©triques de succ√®s

### Objectifs atteints (PHASE 2 - GroupedProposalDetailBase)

‚úÖ Plus de perte de modifications  
‚úÖ Payload complet lors de la validation  
‚úÖ Single Source of Truth (`workingGroup`)  
‚úÖ Sauvegarde automatique (autosave)  
‚úÖ Code plus simple (-150 lignes de logique manuelle)  

### Objectifs atteints (PHASE 2.1 - Alignement WorkingProposal)

‚úÖ Tag "Modifi√©" fonctionnel dans propositions simples  
‚úÖ `WorkingProposal` align√© sur `WorkingProposalGroup`  
‚úÖ `calculateDiff()` simplifi√© (-30 lignes)  
‚úÖ Architecture unifi√©e entre mode simple et mode group√©  

### Objectifs restants (Nettoyage uniquement)

- [x] ProposalDetailBase migr√© vers `useProposalEditor` ‚úÖ
- [x] WorkingProposal align√© sur WorkingProposalGroup ‚úÖ
- [ ] Ancien syst√®me compl√®tement supprim√©
- [ ] `useProposalLogic` √©valu√©/simplifi√©
- [ ] Tests de non-r√©gression complets (manuels)

---

## üë§ Auteur

- **Date** : 2025-11-12
- **Contexte** : PHASE 2 + PHASE 2.1 compl√®tes - Architecture unifi√©e et tag "Modifi√©" fonctionnel partout
